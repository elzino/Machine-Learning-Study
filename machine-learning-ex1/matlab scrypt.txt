사칙연산
+, -, *, /, %(나머지)

== 같다
~= 다르다

&&
||
xor(1,0)


;(세미콜론 넣으면 결과 출력 막는다)

[1, 2, 3]
[1; 2; 3]   -> (3*1) 벡터가 된다

1:0.1:2 -> 1부터 2까지 0.1 단위로 증가하는 벡터

disp - 표준 출력   -> ex) disp(변수)

disp(sprintf('2 decimals: %0.2f', a) )

format long
소수점 14자리

format short
소수점 4자리

A= [1, 2; 3, 4; 5, 6]
은
A =[1, 2;
3 4;
5 6]
이랑 같다

v = 1:6 -> [1 2 3 4 5 6]

c = 2 * ones(2,3)
-> 2 2 2
    2 2 2

w = zeros(1, 3)

w = rand (4, 3) -> 0~1 사이 랜덤 숫자로 행렬 만들어줌
w = randn(1, 3 ) -> 표준정규분포 따르는 랜덤 행렬 만들어줌


hist(w) -> 그래프
hist(w, 50) -> 막대 50개로 그려줌

eye(4) - > 4칸 단위행렬

help 명령어 -> 도움말

size(A) -> 행렬 A의 사이즈를 [1 * 2] 크기의 벡터로 내놓음 

length( 3 * 2 행렬) -> 결과 3
		-> 보통 벡터에 대해 사용

length ( 1 * 4 벡터) -> 결과 4

load featuresX.dat
load('featuresX.dat') -> 둘 다 데이터 불러 오는 것 

'' 작은 따음표를 문자열 나타낼 때 사용

who -> 현재 workspace에 있는 변수, 자료들 나태내줌
whos -> who의 더 자세한 버전
	이름, size, bytes, class

X = featureX(1:10) -> featureX 1부터 10까지
X = featureX(2, 3) -> featureX 2행 3열
X = featureX(1:10, 3:4) -> featureX 1-10행, 3-4열
X = featureX(:, 3) -> featureX 모든 행, 3열
X = featureX(2, :) -> featureX 2 행, 모든 열
X = featureX([1,3], 2) -> featureX 1,3 행, 2열

A(: , 2)  = [10; 11; 12] -> A의 2열에 [10; 11; 12] 대입
A = [A, [100; 101; 102]] -> 기존의 A에다가 오른쪽에 100; 101; 102 덧붙임

A(:) -> A의 모든 원소를 벡터에 넣음
-> (3*3 행렬이였으면 9*1 벡터 됨)


clear -> 워크스페이스 에 모든 변수 지움

save hello.txt featureX -ascii
save hello.mat featureX

%가 주석 시작 알림

C = [A, B] -> A, B 오른쪽으로 붙임

C= [A; B] -> A, B 위 아래로 붙임

--------------------------------------------------------------------
-----------------행렬 연산--------------------------


A .* B -> 원소끼리의 곱( 행렬곱X )
A .^ 2 -> 각 원소 제곱
1 ./ v -> 다 나눈 벡터 나옴

.을 붙이면 원소단위로 계산

log(v) -> 로그 값
exp(v) -> e의 지숫값
abs(v) -> 절댓값

v + ones( length(v), 1) == v + 1    -> v +1 원소단위 덧셈

A' -> A의 전치 행렬 -> AT

val = max(v) -> 최댓값
[val, ind] = max(v) -> 최댓값, 인덱스

max(행렬) -> 열 단위로 max 구함 (1열의 최댓값, 인덱스, 2열의 최댓값, 인덱스 등등)

v < 3 -> 1 0 1 1 과 같이 결과 나옴 (1은 true, 0은 false)
find (v < 3 ) -> 1, 3, 4 결과로 나옴

magic(5) -> 5*5 마방진 만듬

sum(a) -> a 다 더해줌
prod(a) -> a 다 곱해줌

floor(a) -> a 버림 해줌
ceil(a) -> 올림해줌

max(A, [], 1) -> 각 열의 최댓값
->max(A)랑 같음

max(A, [], 2) -> 각 행의 최댓값

 A = magic(10)

flipud -> flip up down 의미 -> 위 아래 바꿈

pinv(A) -> 역행렬 구해줌


--------------------------Plot----------------------------
t = [0 : 0.01 : 0.98]
y1 = sin(2*pi*4*t)
y2 = cos(2*pi*4*t)

plot(t,y1)
plot(t,y2)

hold on -> 그래프 겹쳐서 보여줌

plot(t,y2, 'r') -> 색깔 빨간색

xlabel('time')
ylabel('value')
legend('sin', 'cos')
title('blabla')

print -dpng 'myPlot.png'    -> 그래프 png로 저장

figure(1); plot(t,y1);    ->    창1에다가 띄움
figure(2); plot(t,y2);    ->    창2에다가 띄움

subplot(1,2,1) -> 1*2 의 그래프 그리드를 가지고 현재 위치는 1으로 함

axis([0.5, 1, -1, 1]) - 처음 두개 x 범위, 

clf -> 현재 figure 창 지우기

A = magic(5);

imagesc(A), colorbar, colormap gray; -> 값을 색깔로 표시해줌

,로 연결하면 명령어 이어서 바로바로 실행하는 것


